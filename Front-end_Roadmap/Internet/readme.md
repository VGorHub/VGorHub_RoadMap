<h1 align = "center">
Internet
</h1>

<h3 > Tasks: </h3>

* [How does the internet work?](#HowDoesTheInternetWork?)

* [What is HTTP?](#WhatIsHTTP?)

* [Browsers and how they work?](#BrowsersAndHowTheyWork?)

* [DNS and how it works?](#DNSAndHowItWorks?)

* [What is Domain Name?](#WhatIsDomainName?)

* [What is hosting?](#WhatIsHosting?)




# HowDoesTheInternetWork?

### Basic Concepts and Terminology:

* Packet: небольшая единица данных, которая передается через Интернет.Имеет инфу о том кто отправил и кому идет.Обычно все отправляемые данные делится на маленькие пакеты.


* Router: устройство, которое направляет пакеты данных между различными сетями.


* IP Address: уникальный идентификатор, назначаемый каждому устройству в сети, используемый для маршрутизации данных в нужное место назначения.

* TCP: Transmission Control Protocol гарантирует, что пакеты передаются надежно и в правильном порядке.Он проверяет все ли пакеты пришли и в полном ли объеме, если обнаружит что не хватет пакетов то он запросит повторную отправку недостающих пакетов.

* Domain Name: понятное для человека имя, которое используется для идентификации веб-сайта, например google.com.

* DNS: The Domain Name System (Система доменных имен) отвечает за преобразование доменных имен в IP-адреса.


* HTTP: The Hypertext Transfer Protocol (Протокол передачи гипертекста) используется для передачи данных между клиентом (например, веб-браузером) и сервером (например, веб-сайтом).


* HTTPS: зашифрованная версия HTTP, которая используется для обеспечения безопасной связи между клиентом и сервером.


* SSL/TLS: The Secure Sockets Layer and Transport Layer Security protocols используются для обеспечения безопасной связи через Интернет.

* ISP: Internet Service Provider.

* Ports: Порты используются для идентификации приложения или службы, запущенной на устройстве. Каждому приложению или службе присваивается уникальный номер порта, позволяющий отправлять данные правильному адресату.

* Sockets: Сокет представляет собой комбинацию IP-адреса и номера порта, представляющую определенную конечную точку для связи. Сокеты используются для установления соединений между устройствами и передачи данных между приложениями.

### The Role of Protocols in Internet


IP отвечает за маршрутизацию пакетов данных к их правильному месту назначения,в то время как TCP и UDP обеспечивают надежную и эффективную передачу пакетов.DNS используется для преобразования доменных имен в IP-адреса, а HTTP используется для передачи данных между клиентами и серверами.



### Understanding IP Addresses and Domain Names

IP-адрес - это уникальный идентификатор, присваиваемый каждому устройству в сети. Он используется для маршрутизации данных в правильное место назначения, IP-адреса обычно представлены в виде серии из четырех чисел, разделенных точками, например “192.168.1.1”.

<p></p>

DNS - важнейшая часть инфраструктуры Интернета, отвечающая за преобразование доменных имен в IP-адреса. Когда вы вводите доменное имя в свой веб-браузер, ваш компьютер отправляет DNS-запрос на DNS-сервер, который возвращает соответствующий IP-адрес. Затем ваш компьютер использует этот IP-адрес для подключения к веб-сайту или другому ресурсу, который вы запросили.

### Introduction to HTTP and HTTPS
HTTP - это протокол, используемый для передачи данных между клиентом (например, веб-браузером) и сервером (например, веб-сайтом). Когда вы посещаете веб-сайт, ваш веб-браузер отправляет HTTP-запрос на сервер, запрашивая веб-страницу или другой ресурс, который вы запросили. Затем сервер отправляет HTTP-ответ обратно клиенту, содержащий запрошенные данные.

<p></p>

HTTPS - это более безопасная версия HTTP, которая шифрует данные, передаваемые между клиентом и сервером, с использованием шифрования SSL / TLS (Secure Sockets Layer / Transport Layer Security). Это обеспечивает дополнительный уровень безопасности, помогая защитить конфиденциальную информацию, такую как учетные данные для входа, платежную информацию и другие личные данные.

### Securing Internet Communication with SSL/TLS
Сегодня безопасная связь шифруется с помощью 256-битных ключей. 

Есть симетричное ключи - это когда оба получают один и тот же ключ.Но безопасно не полуится тайно устроить встречу 2-х ПК.
    
Поэтому используется асиметричные ключи. Открытый ключ можно дать кому угодно, а вот приватный уже никому не раскрывается.Открытый ключ используется для шифрования данных и кто угодно может им зашифровать сообщение, но расшифровать может только Пк который имеет Приватный Ключ.
    
Это делается как-то математически. 

* Certificates: Сертификаты SSL / TLS используются для установления доверия между клиентом и сервером. Они содержат информацию о личности сервера и подписаны доверенной третьей стороной (Центром сертификации) для проверки их подлинности.

* Handshake: В процессе рукопожатия SSL / TLS клиент и сервер обмениваются информацией для согласования алгоритма шифрования и других параметров безопасного соединения.

* Encryption: После установления защищенного соединения данные шифруются с использованием согласованного алгоритма и могут безопасно передаваться между клиентом и сервером.

# WhatIsHTTP?

HTTP - это протокол связи прикладного уровня на основе TCP / IP, который стандартизирует взаимодействие клиентов и серверов друг с другом. Он определяет, как запрашивается и передается контент через Интернет. Под протоколом прикладного уровня я подразумеваю, что это просто уровень абстракции, который стандартизирует взаимодействие хостов (клиентов и серверов).

### Что содержится в HTTP-request?
 HTTP request это способ, с помощью которого платформы интернет-коммуникаций, такие как веб-браузеры, запрашивают информацию, необходимую им для загрузки веб-сайта.

Каждый HTTP-запрос, отправляемый через Интернет, содержит серию закодированных данных, которые содержат различные типы информации. Типичный HTTP-запрос содержит:

* Тип версии HTTP
* URL-адрес
* HTTP-метод
* Заголовки HTTP-запросов
* Необязательное тело HTTP.

Метод HTTP, иногда называемый HTTP-глаголом, указывает действие, которое HTTP-запрос ожидает от запрашиваемого сервера. Например, двумя наиболее распространенными HTTP-методами являются ‘GET’ и ‘POST’; при запросе ‘GET’ в ответ ожидается информация (обычно в виде веб-сайта), в то время как запрос ‘POST’ обычно указывает, что клиент отправляет информацию веб-серверу (например, информацию формы, например, отправленные имя пользователя и пароль).

### Что такое заголовки HTTP-запросов?
Заголовки HTTP содержат текстовую информацию, хранящуюся в парах ключ-значение, и они включаются в каждый HTTP-запрос (и ответ, подробнее об этом позже). Эти заголовки передают основную информацию, например, какой браузер использует клиент и какие данные запрашиваются.

Пример заголовков HTTP-запроса на вкладке сеть в Google Chrome:

![Пример заголовков HTTP-запроса на вкладке сеть в Google Chrome](https://www.cloudflare.com/img/learning/ddos/glossary/hypertext-transfer-protocol-http/http-request-headers.png)

### Что находится в теле HTTP-запроса?
Тело запроса - это часть, которая содержит ‘тело’ информации, передаваемой запросом. Тело HTTP-запроса содержит любую информацию, отправляемую на веб-сервер, такую как имя пользователя и пароль, или любые другие данные, введенные в форму.

### Что содержится в HTTP-ответе?
HTTP-ответ - это то, что веб-клиенты (часто браузеры) получают от интернет-сервера в ответ на HTTP-запрос. Эти ответы передают ценную информацию, основанную на том, что было запрошено в HTTP-запросе.

Типичный HTTP-ответ содержит:

* код состояния HTTP
* Заголовки HTTP-ответов
* необязательное тело HTTP

### Что такое код состояния HTTP?
Коды состояния HTTP - это трехзначные коды, чаще всего используемые для указания того, был ли успешно выполнен HTTP-запрос. Коды состояния разбиты на следующие 5 блоков:

* 1xx Информационный
* 2xx Успех
* Перенаправление 3xx
* Ошибка клиента 4xx
* Ошибка сервера 5xx

“xx” обозначает разные числа от 00 до 99.

###Что такое заголовки HTTP-ответов?
Как и HTTP-запрос, HTTP-ответ содержит заголовки, которые передают важную информацию, такую как язык и формат данных, отправляемых в теле ответа.

Пример заголовков HTTP-ответа на вкладке сеть в Google Chrome:

![Пример заголовков HTTP-ответа на вкладке сеть в Google Chrome](https://www.cloudflare.com/img/learning/ddos/glossary/hypertext-transfer-protocol-http/http-response-headers.png)


### Что находится в теле HTTP-ответа?
Успешные HTTP-ответы на запросы ‘GET’ обычно имеют тело, содержащее запрошенную информацию. В большинстве веб-запросов это HTML-данные, которые веб-браузер преобразует в веб-страницу.

## History of HTTP


### HTTP/ 0.9
Это был самый простой протокол из когда-либо существовавших; он содержал единственный метод под названием GET . Если бы клиенту нужно было получить доступ к какой-либо веб-странице на сервере, он бы отправил простой запрос, как показано ниже
```h
    GET /index.html
```

И ответе сервера, выглядело бы следующим образом
```h
    (response body)
    (connection closed)
```
### HTTP/ 1.0
HTTP / 1.0 теперь может работать и с другими форматами ответов, такими как изображения, видеофайлы, обычный текст или любой другой тип контента. Добавлено больше методов (например, POST и HEAD), изменены форматы запроса / ответа, добавлены заголовки HTTP как к запросу, так и к ответам, добавлены коды состояния для идентификации ответа, введена поддержка набора символов, включены составные типы, авторизация, кэширование, кодирование контента и многое другое.

Вот как мог бы выглядеть пример запроса и ответа HTTP / 1.0:
    GET / HTTP/1.0
    Host: cs.fyi
    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
    Accept: */*

Как вы можете видеть, вместе с запросом клиент также отправил свою личную информацию, требуемый тип ответа и т.д.

Пример ответа на приведенный выше запрос может выглядеть следующим образом

```h
    HTTP/1.0 200 OK 
    Content-Type: text/plain
    Content-Length: 137582
    Expires: Thu, 05 Dec 1997 16:00:00 GMT
    Last-Modified: Wed, 5 August 1996 15:55:28 GMT
    Server: Apache 0.84

    (response body)
    (connection closed)
```
Одним из основных недостатков HTTP / 1.0 было невозможность выполнения нескольких запросов на одно соединение. То есть всякий раз, когда клиенту что-то понадобится от сервера, ему придется открывать новое TCP-соединение, и после того, как этот единственный запрос будет выполнен, соединение будет закрыто. И для любого следующего требования, он должен быть подключен к новому соединению.

### Three-way Handshake

Трехстороннее рукопожатие в его простой форме заключается в том, что все TCP-соединения начинаются с трехстороннего рукопожатия, при котором клиент и сервер обмениваются серией пакетов, прежде чем начать обмениваться данными приложения.

* SYN - клиент выбирает случайное число, скажем x, и отправляет его на сервер.
* SYN ACK - Сервер подтверждает запрос, отправляя пакет ACK обратно клиенту, который состоит из случайного числа, скажем, y, полученного сервером, и числа x + 1, где x - это число, отправленное клиентом
* ACK - клиент увеличивает число y, полученное от сервера, и отправляет обратно пакет ACK с числом y + 1

После завершения трехстороннего подтверждения связи может начаться обмен данными между клиентом и сервером. Следует отметить, что клиент может начать отправку данных приложения, как только он отправит последний подтверждающий пакет, но серверу все равно придется ждать получения подтверждающего пакета, чтобы выполнить запрос.

![Exemple of Three-way Handshake](https://i.imgur.com/ohZthqB.png)

### HTTP/1.1
Основные улучшения по сравнению с HTTP / 1.0 включали

* Были добавлены новые методы HTTP, которые представили PUT, PATCH, OPTIONS, DELETE

* Идентификация имени хоста В заголовке HTTP / 1.0 Host не требовалась, но HTTP / 1.1 сделал это обязательным.

* Были введены постоянные соединения, т. е. соединения не закрывались по умолчанию и оставались открытыми, что позволяло выполнять несколько последовательных запросов. Чтобы закрыть соединения, в запросе должен был быть доступен заголовок Connection: close . Клиенты обычно отправляют этот заголовок в последнем запросе, чтобы безопасно закрыть соединение.

* Конвейерная обработка Также была представлена поддержка конвейерной обработки, когда клиент мог отправлять несколько запросов на сервер, не дожидаясь ответа от сервера по тому же соединению, и сервер должен был отправлять ответ в той же последовательности, в которой были получены запросы. Но как клиент узнает, что на этом загрузка первого ответа завершается и начинается содержимое для следующего ответа, спросите вы! Ну, чтобы решить эту проблему, должен присутствовать заголовок Content-Length, который клиенты могут использовать для определения того, где заканчивается ответ, и он может начать ждать следующего ответа.

* Фрагментированные передачи В случае динамического содержимого, когда сервер не может точно определить длину содержимого при начале передачи, он может начать отправлять содержимое частями (фрагмент за фрагментом) и добавлять длину содержимого для каждого фрагмента при его отправке. И когда все фрагменты отправлены, т. е. передача целиком завершена, он отправляет пустой фрагмент, т. Е. Тот, длина содержимого которого равна нулю, чтобы идентифицировать клиента, передача которого завершена. Для того, чтобы уведомить клиента о фрагментированной передаче, сервер включает заголовок Transfer-Encoding: chunked

* В отличие от HTTP / 1.0, который имел только базовую аутентификацию, HTTP / 1.1 включал аутентификацию через дайджест и прокси

* Кэширование

* Диапазоны байтов

* Наборы символов

* Согласование языка

* Клиентские файлы cookie

### HTTP/2 - 2015

HTTP. HTTP / 2 был разработан для передачи контента с низкой задержкой. Ключевые особенности или отличия от старой версии HTTP / 1.1 включают

* Binary instead of Textual
* Multiplexing - несколько асинхронных HTTP-запросов через одно соединение
* Header compression using HPACK
* Server Push - несколько ответов на один запрос
* Приоритизация запросов
* Безопасность

#### Binary Protocol

HTTP / 2, как правило, решает проблему повышенной задержки, которая существовала в HTTP / 1.x, превращая его в двоичный протокол. Поскольку это двоичный протокол, его проще анализировать, но в отличие от HTTP / 1.x он больше не читаем человеческим глазом. Основными строительными блоками HTTP / 2 являются фреймы и потоки Frames and Streams

#### Frames and Streams

HTTP-сообщения теперь состоят из одного или нескольких фреймов. Существует фрейм HEADERS  для метаданных и фрейм DATA  для полезной нагрузки, а также существует несколько других типов фреймов (ЗHEADERS, DATA, RST_STREAM, SETTINGS, PRIORITY etc)

Каждому запросу и ответу HTTP / 2 присваивается уникальный идентификатор потока, и он разделяется на фреймы. Фреймы - это не что иное, как двоичные фрагменты данных. Набор фреймов называется потоком. Каждый фрейм имеет идентификатор потока, который идентифицирует поток, к которому он принадлежит, и каждый фрейм имеет общий заголовок. Также, помимо того, что идентификатор потока уникален, стоит упомянуть, что любой запрос, инициированный клиентом, использует нечетные числа, а ответ от сервера имеет идентификаторы потока четных чисел.

Помимо HEADERS and DATA, еще один тип фрейма, который, я думаю, стоит упомянуть здесь, - это RST_STREAM, который представляет собой специальный тип фрейма, который используется для прерывания некоторого потока, т.Е. клиент может отправить этот фрейм, чтобы сообщить серверу, что мне больше не нужен этот поток.

#### Multiplexing
Поскольку HTTP / 2 теперь является двоичным протоколом и, как я сказал выше, он использует фреймы и потоки для запросов и ответов, после открытия TCP-соединения все потоки отправляются асинхронно через одно и то же соединение без открытия каких-либо дополнительных подключений. И, в свою очередь, сервер отвечает таким же асинхронным образом, т. е. Ответ не имеет порядка, и клиент использует назначенный идентификатор потока для идентификации потока, к которому принадлежит конкретный пакет.
#### Server Push
Серверный push - это еще одна потрясающая функция HTTP / 2, при которой сервер, зная, что клиент собирается запросить определенный ресурс, может отправить его клиенту, даже не запрашивая его у клиента. Например, предположим, что браузер загружает веб-страницу, он анализирует всю страницу, чтобы найти удаленный контент, который он должен загрузить с сервера, а затем отправляет последующие запросы на сервер для получения этого контента.

Server push позволяет серверу уменьшить количество обходов, передавая данные, которые, как он знает, будет запрашивать клиент. Как это делается, сервер отправляет специальный фрейм с именем PUSH_PROMISE, уведомляющий клиента о том, что “Эй, я собираюсь отправить вам этот ресурс! Не спрашивайте меня об этом.” Фрейм PUSH_PROMISE связан с потоком, который вызвал отправку запроса, и он содержит обещанный идентификатор потока, то есть поток, по которому сервер отправит ресурс для отправки.

#### Определение приоритета запросов

Клиент может назначить приоритет потоку, включив информацию о приоритизации во фрейм HEADERS, с помощью которого открывается поток. В любое другое время клиент может отправить фрейм PRIORITY для изменения приоритета потока.

Без какой-либо информации о приоритете сервер обрабатывает запросы асинхронно, т.е. без какого-либо порядка. Если потоку присвоен приоритет, то на основе этой информации о приоритизации сервер решает, сколько ресурсов необходимо выделить для обработки того или иного запроса.

# WhatIsDomainName?
### Структура доменных имен

Доменное имя имеет простую структуру, состоящую из нескольких частей (это может быть только одна часть, две, три ...), разделенных точками и читаемых справа налево:

![Пример Структуры](https://developer.mozilla.org/en-US/docs/Learn/Common_questions/Web_mechanics/What_is_a_domain_name/structure.png)

TLD (Top-Level Domain).
TLD сообщают пользователям общее назначение службы, стоящей за доменным именем. Самые общие TLD (.com, .org, .net) не требуют, чтобы веб-сервисы соответствовали каким-либо конкретным критериям, но в некоторых TLD применяются более строгие политики, чтобы было понятнее, какова их цель. Например:

* Локальные TLD, такие как .us, .fr или .se могут требовать предоставления услуг на определенном языке или размещения в определенной стране — предполагается, что они указывают ресурс на определенном языке или стране.
* ДВУ, содержащие .gov, разрешены к использованию только государственными ведомствами.
* .edu TLD предназначен только для образовательных учреждений.

TLD могут содержать как специальные, так и латинские символы. Максимальная длина TLD составляет 63 символа, хотя большинство из них составляют около 2-3.

### Метка (или компонент)
Метки следуют за TLD. Метка - это последовательность символов длиной от одного до шестидесяти трех символов без учета регистра, содержащая только буквы от A до Z, цифры от 0 до 9 и символ "-" (который может не быть первым или последним символом в метке). a, 97 и hello-strange-person-16-how-are-you все это примеры допустимых меток.

Метка, расположенная непосредственно перед TLD, также называется Secondary Level Domain (SLD).

Доменное имя может иметь много меток (или компонентов). Для формирования доменного имени не обязательно иметь 3 метки. Например, www.inf.ed.ac.uk это действительное доменное имя. Для любого домена, которым вы управляете (например, mozilla.org), вы можете создать "поддомены" с различным контентом, расположенным на каждом, например developer.mozilla.org, iot.mozilla.org или bugzilla.mozilla.org.

### Как работает DNS-запрос?
Как мы уже видели, когда вы хотите отобразить веб-страницу в своем браузере, проще ввести доменное имя, чем IP-адрес. Давайте рассмотрим процесс:

Введите mozilla.org в строке местоположения вашего браузера.
Ваш браузер запрашивает ваш компьютер, распознает ли он уже IP-адрес, указанный этим доменным именем (используя локальный кэш DNS). Если это так, имя преобразуется в IP-адрес, и браузер согласовывает содержимое с веб-сервером. Конец истории.
Если ваш компьютер не знает, какой IP стоит за mozilla.org именем, он запрашивает DNS-сервер, чья работа заключается именно в том, чтобы сообщить вашему компьютеру, какой IP-адрес соответствует каждому зарегистрированному доменному имени.
Теперь, когда компьютеру известен запрошенный IP-адрес, ваш браузер может согласовывать содержимое с веб-сервером.

![Пример](https://developer.mozilla.org/en-US/docs/Learn/Common_questions/Web_mechanics/What_is_a_domain_name/2014-10-dns-request2.png)

# WhatIsHosting?
Существуют разные виды хостингов: 
* Shared Hosting 
* Reselle Hostingr
* Virtual Private Servers 
* Dedicated Servers

### Shared Hosting 
- Много людей могут находится на 1 машине.
- Один из самых дешёвых вариантов.
- Могут подвергаться DDoS.

### VPS (Virtual Private Servers )
- Отдельный изолированный сервер.
- Находится на 1 машине с другими серверами но уже на другом уровне разраничения.
- Грубо говоря отдельная ОС в твоем распоряжении в то врямя когда Shared Hosting все в 1 OC.
- Можно размещать много серверов и баз данных в пределах Мощностей VPS
- Сложно управлять(Командная строка)

### Dedicated Servers
- VPS только вся мащина принадлежит тебе
- Не скем не делишься 
- Нельзя легко обновиться на более мощную модель

# DNSAndHowItWorks?
### В загрузке веб-страницы участвуют 4 DNS-сервера:
* DNS recursor - Повторителя можно рассматривать как библиотекаря, которого просят найти определенную книгу где-нибудь в библиотеке. DNS recursor - это сервер, предназначенный для приема запросов от клиентских компьютеров через приложения, такие как веб-браузеры. Обычно recursor отвечает за выполнение дополнительных запросов для удовлетворения DNS-запроса клиента.
* Root nameserver - корневой сервер является первым шагом в преобразовании (разрешении) удобочитаемых имен узлов в IP-адреса. Его можно рассматривать как указатель в библиотеке, который указывает на разные стеллажи с книгами - обычно он служит ссылкой на другие, более конкретные местоположения.
* TLD nameserver - Сервер домена верхнего уровня (TLD) можно рассматривать как определенную полку с книгами в библиотеке. Этот сервер имен является следующим шагом в поиске определенного IP-адреса, и на нем размещается последняя часть имени хоста (в example.com сервер TLD - “com”).
* Authoritative nameserver - Этот конечный сервер имен можно рассматривать как словарь на полке с книгами, в котором конкретное имя может быть переведено в его определение. Авторитетный сервер имен является последней остановкой в запросе сервера имен. Если авторизованный сервер имен имеет доступ к запрошенной записи, он вернет IP-адрес для запрошенного имени хоста обратно поставщику DNS (библиотекарю), который отправил первоначальный
### 8 шагов поиска DNS:
1. Пользователь вводит ‘example.com’ в веб-браузере, запрос отправляется в Интернет и принимается рекурсивным преобразователем DNS.
1. Затем распознаватель запрашивает корневой сервер имен DNS (.).
1. Затем корневой сервер отвечает распознавателю адресом DNS-сервера домена верхнего уровня (TLD) (такого как .com или .net), который хранит информацию для своих доменов. При поиске по запросу example.com наш запрос указывает на TLD .com.
1. Затем распознаватель отправляет запрос в TLD .com.
1. Затем сервер TLD отвечает IP-адресом сервера имен домена, example.com.
1. Наконец, рекурсивный преобразователь отправляет запрос на сервер имен домена.
1. IP-адрес для example.com затем возвращается распознавателю с сервера имен.
1. Затем распознаватель DNS отправляет веб-браузеру IP-адрес домена, запрошенный изначально.
 * После того, как 8 шагов поиска в DNS вернут IP-адрес для example.com, браузер сможет отправить запрос для веб-страницы:

9. Браузер отправляет HTTP запрос на IP-адрес.
1. Сервер с этим IP-адресом возвращает веб-страницу для отображения в браузере (шаг 10).
![Пример](https://cf-assets.www.cloudflare.com/slt3lc6tev37/1NzaAqpEFGjqTZPAS02oNv/bf7b3f305d9c35bde5c5b93a519ba6d5/what_is_a_dns_server_dns_lookup.png)
### Что такое распознаватель DNS?
Распознаватель DNS - это первая остановка в поиске DNS, и он отвечает за обработку клиента, отправившего первоначальный запрос. Распознаватель запускает последовательность запросов, которая в конечном итоге приводит к преобразованию URL-адреса в необходимый IP-адрес.

Примечание: Типичный некэшированный поиск DNS будет включать как рекурсивные, так и итеративные запросы.

Важно различать рекурсивный DNS запрос и рекурсивный преобразователь DNS. Запрос относится к запросу, отправленному в преобразователь DNS, требующему разрешения запроса. Рекурсивный распознаватель DNS - это компьютер, который принимает рекурсивный запрос и обрабатывает ответ, отправляя необходимые запросы.


### 3 типа DNS-запросов:
1. Рекурсивный запрос - При рекурсивном запросе DNS-клиент требует, чтобы DNS-сервер (обычно рекурсивный преобразователь DNS) ответил клиенту либо запрошенной записью ресурса, либо сообщением об ошибке, если преобразователь не может найти запись.
1. Итеративный запрос - в этой ситуации DNS-клиент позволит DNS-серверу вернуть наилучший ответ, на который он способен. Если запрошенный DNS-сервер не соответствует имени запроса, он вернет ссылку на DNS-сервер, авторизованный для более низкого уровня пространства имен домена. Затем DNS-клиент отправит запрос на адрес ссылки. Этот процесс продолжается с дополнительными DNS-серверами в цепочке запросов до тех пор, пока не произойдет ошибка или тайм-аут.
1. Нерекурсивный запрос - обычно это происходит, когда клиент DNS-распознавателя запрашивает у DNS-сервера запись, к которой у него есть доступ, либо потому, что она является авторитетной для записи, либо запись существует внутри его кэша. Обычно DNS-сервер кэширует DNS-записи, чтобы предотвратить дополнительное потребление полосы пропускания и нагрузку на вышестоящие серверы.

### Что такое кэширование DNS? Где происходит кэширование DNS?
Целью кэширования является временное хранение данных в месте, что приводит к повышению производительности и надежности запросов данных. Кэширование DNS предполагает хранение данных ближе к запрашивающему клиенту, чтобы DNS-запрос мог быть разрешен раньше и можно было избежать дополнительных запросов дальше по цепочке поиска DNS, тем самым увеличивая время загрузки и снижая пропускную способность / потребление ЦП. Данные DNS могут кэшироваться в различных местах, каждое из которых будет хранить записи DNS в течение определенного периода времени, определяемого временем жизни (TTL).
* Кэширование DNS в браузере.
    - Когда делается запрос на запись DNS, кэш браузера является первым местоположением, проверяемым на наличие запрошенной записи.
* Кэширование DNS на уровне операционной системы (OS)
    - Распознаватель DNS на уровне операционной системы - это вторая и последняя локальная остановка перед тем, как DNS-запрос покинет ваш компьютер. Процесс внутри вашей операционной системы, предназначенный для обработки этого запроса, обычно называется “распознавателем заглушек” или DNS-клиентом. Когда распознаватель заглушек получает запрос от приложения, он сначала проверяет свой собственный кэш, чтобы увидеть, есть ли в нем запись. Если это не так, затем он отправляет DNS-запрос (с установленным рекурсивным флагом) за пределы локальной сети на DNS-рекурсивный распознаватель внутри интернет-провайдера (ISP).

    - Когда рекурсивный преобразователь внутри интернет-провайдера получает DNS-запрос, как и на всех предыдущих шагах, он также проверяет, сохранено ли запрошенное преобразование хоста в IP-адрес на его локальном уровне сохраняемости.

# BrowsersAndHowTheyWork?

