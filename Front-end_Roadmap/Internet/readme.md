<h1 align = "center">
Internet
</h1>

<h3 > Tasks: </h3>

* [How does the internet work?](#HowDoesTheInternetWork?)

* [What is HTTP?](#WhatIsHTTP?)

* [Browsers and how they work?](#BrowsersAndHowTheyWork?)

* [DNS and how it works?](#DNSAndHowItWorks?)

* [What is Domain Name?](#WhatIsDomainName?)

* [What is hosting?](#WhatIsHosting?)




# HowDoesTheInternetWork?

### Basic Concepts and Terminology:

* Packet: небольшая единица данных, которая передается через Интернет.Имеет инфу о том кто отправил и кому идет.Обычно все отправляемые данные делится на маленькие пакеты.


* Router: устройство, которое направляет пакеты данных между различными сетями.


* IP Address: уникальный идентификатор, назначаемый каждому устройству в сети, используемый для маршрутизации данных в нужное место назначения.

* TCP: Transmission Control Protocol гарантирует, что пакеты передаются надежно и в правильном порядке.Он проверяет все ли пакеты пришли и в полном ли объеме, если обнаружит что не хватет пакетов то он запросит повторную отправку недостающих пакетов.

* Domain Name: понятное для человека имя, которое используется для идентификации веб-сайта, например google.com.

* DNS: The Domain Name System (Система доменных имен) отвечает за преобразование доменных имен в IP-адреса.


* HTTP: The Hypertext Transfer Protocol (Протокол передачи гипертекста) используется для передачи данных между клиентом (например, веб-браузером) и сервером (например, веб-сайтом).


* HTTPS: зашифрованная версия HTTP, которая используется для обеспечения безопасной связи между клиентом и сервером.


* SSL/TLS: The Secure Sockets Layer and Transport Layer Security protocols используются для обеспечения безопасной связи через Интернет.

* ISP: Internet Service Provider.

* Ports: Порты используются для идентификации приложения или службы, запущенной на устройстве. Каждому приложению или службе присваивается уникальный номер порта, позволяющий отправлять данные правильному адресату.

* Sockets: Сокет представляет собой комбинацию IP-адреса и номера порта, представляющую определенную конечную точку для связи. Сокеты используются для установления соединений между устройствами и передачи данных между приложениями.

### The Role of Protocols in Internet


IP отвечает за маршрутизацию пакетов данных к их правильному месту назначения,в то время как TCP и UDP обеспечивают надежную и эффективную передачу пакетов.DNS используется для преобразования доменных имен в IP-адреса, а HTTP используется для передачи данных между клиентами и серверами.



### Understanding IP Addresses and Domain Names

IP-адрес - это уникальный идентификатор, присваиваемый каждому устройству в сети. Он используется для маршрутизации данных в правильное место назначения, IP-адреса обычно представлены в виде серии из четырех чисел, разделенных точками, например “192.168.1.1”.

<p></p>

DNS - важнейшая часть инфраструктуры Интернета, отвечающая за преобразование доменных имен в IP-адреса. Когда вы вводите доменное имя в свой веб-браузер, ваш компьютер отправляет DNS-запрос на DNS-сервер, который возвращает соответствующий IP-адрес. Затем ваш компьютер использует этот IP-адрес для подключения к веб-сайту или другому ресурсу, который вы запросили.

### Introduction to HTTP and HTTPS
HTTP - это протокол, используемый для передачи данных между клиентом (например, веб-браузером) и сервером (например, веб-сайтом). Когда вы посещаете веб-сайт, ваш веб-браузер отправляет HTTP-запрос на сервер, запрашивая веб-страницу или другой ресурс, который вы запросили. Затем сервер отправляет HTTP-ответ обратно клиенту, содержащий запрошенные данные.

<p></p>

HTTPS - это более безопасная версия HTTP, которая шифрует данные, передаваемые между клиентом и сервером, с использованием шифрования SSL / TLS (Secure Sockets Layer / Transport Layer Security). Это обеспечивает дополнительный уровень безопасности, помогая защитить конфиденциальную информацию, такую как учетные данные для входа, платежную информацию и другие личные данные.

### Securing Internet Communication with SSL/TLS
Сегодня безопасная связь шифруется с помощью 256-битных ключей. 

Есть симетричное ключи - это когда оба получают один и тот же ключ.Но безопасно не полуится тайно устроить встречу 2-х ПК.
    
Поэтому используется асиметричные ключи. Открытый ключ можно дать кому угодно, а вот приватный уже никому не раскрывается.Открытый ключ используется для шифрования данных и кто угодно может им зашифровать сообщение, но расшифровать может только Пк который имеет Приватный Ключ.
    
Это делается как-то математически. 

* Certificates: Сертификаты SSL / TLS используются для установления доверия между клиентом и сервером. Они содержат информацию о личности сервера и подписаны доверенной третьей стороной (Центром сертификации) для проверки их подлинности.

* Handshake: В процессе рукопожатия SSL / TLS клиент и сервер обмениваются информацией для согласования алгоритма шифрования и других параметров безопасного соединения.

* Encryption: После установления защищенного соединения данные шифруются с использованием согласованного алгоритма и могут безопасно передаваться между клиентом и сервером.

# WhatIsHTTP?

HTTP - это протокол связи прикладного уровня на основе TCP / IP, который стандартизирует взаимодействие клиентов и серверов друг с другом. Он определяет, как запрашивается и передается контент через Интернет. Под протоколом прикладного уровня я подразумеваю, что это просто уровень абстракции, который стандартизирует взаимодействие хостов (клиентов и серверов).

### Что содержится в HTTP-request?
 HTTP request это способ, с помощью которого платформы интернет-коммуникаций, такие как веб-браузеры, запрашивают информацию, необходимую им для загрузки веб-сайта.

Каждый HTTP-запрос, отправляемый через Интернет, содержит серию закодированных данных, которые содержат различные типы информации. Типичный HTTP-запрос содержит:

* Тип версии HTTP
* URL-адрес
* HTTP-метод
* Заголовки HTTP-запросов
* Необязательное тело HTTP.

Метод HTTP, иногда называемый HTTP-глаголом, указывает действие, которое HTTP-запрос ожидает от запрашиваемого сервера. Например, двумя наиболее распространенными HTTP-методами являются ‘GET’ и ‘POST’; при запросе ‘GET’ в ответ ожидается информация (обычно в виде веб-сайта), в то время как запрос ‘POST’ обычно указывает, что клиент отправляет информацию веб-серверу (например, информацию формы, например, отправленные имя пользователя и пароль).

### Что такое заголовки HTTP-запросов?
Заголовки HTTP содержат текстовую информацию, хранящуюся в парах ключ-значение, и они включаются в каждый HTTP-запрос (и ответ, подробнее об этом позже). Эти заголовки передают основную информацию, например, какой браузер использует клиент и какие данные запрашиваются.

Пример заголовков HTTP-запроса на вкладке сеть в Google Chrome:

![Пример заголовков HTTP-запроса на вкладке сеть в Google Chrome](https://www.cloudflare.com/img/learning/ddos/glossary/hypertext-transfer-protocol-http/http-request-headers.png)

### Что находится в теле HTTP-запроса?
Тело запроса - это часть, которая содержит ‘тело’ информации, передаваемой запросом. Тело HTTP-запроса содержит любую информацию, отправляемую на веб-сервер, такую как имя пользователя и пароль, или любые другие данные, введенные в форму.

### Что содержится в HTTP-ответе?
HTTP-ответ - это то, что веб-клиенты (часто браузеры) получают от интернет-сервера в ответ на HTTP-запрос. Эти ответы передают ценную информацию, основанную на том, что было запрошено в HTTP-запросе.

Типичный HTTP-ответ содержит:

* код состояния HTTP
* Заголовки HTTP-ответов
* необязательное тело HTTP

### Что такое код состояния HTTP?
Коды состояния HTTP - это трехзначные коды, чаще всего используемые для указания того, был ли успешно выполнен HTTP-запрос. Коды состояния разбиты на следующие 5 блоков:

* 1xx Информационный
* 2xx Успех
* Перенаправление 3xx
* Ошибка клиента 4xx
* Ошибка сервера 5xx

“xx” обозначает разные числа от 00 до 99.

###Что такое заголовки HTTP-ответов?
Как и HTTP-запрос, HTTP-ответ содержит заголовки, которые передают важную информацию, такую как язык и формат данных, отправляемых в теле ответа.

Пример заголовков HTTP-ответа на вкладке сеть в Google Chrome:

![Пример заголовков HTTP-ответа на вкладке сеть в Google Chrome](https://www.cloudflare.com/img/learning/ddos/glossary/hypertext-transfer-protocol-http/http-response-headers.png)


### Что находится в теле HTTP-ответа?
Успешные HTTP-ответы на запросы ‘GET’ обычно имеют тело, содержащее запрошенную информацию. В большинстве веб-запросов это HTML-данные, которые веб-браузер преобразует в веб-страницу.

## History of HTTP


### HTTP/ 0.9
Это был самый простой протокол из когда-либо существовавших; он содержал единственный метод под названием GET . Если бы клиенту нужно было получить доступ к какой-либо веб-странице на сервере, он бы отправил простой запрос, как показано ниже
```h
    GET /index.html
```

И ответе сервера, выглядело бы следующим образом
```h
    (response body)
    (connection closed)
```
### HTTP/ 1.0
HTTP / 1.0 теперь может работать и с другими форматами ответов, такими как изображения, видеофайлы, обычный текст или любой другой тип контента. Добавлено больше методов (например, POST и HEAD), изменены форматы запроса / ответа, добавлены заголовки HTTP как к запросу, так и к ответам, добавлены коды состояния для идентификации ответа, введена поддержка набора символов, включены составные типы, авторизация, кэширование, кодирование контента и многое другое.

Вот как мог бы выглядеть пример запроса и ответа HTTP / 1.0:
    GET / HTTP/1.0
    Host: cs.fyi
    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
    Accept: */*

Как вы можете видеть, вместе с запросом клиент также отправил свою личную информацию, требуемый тип ответа и т.д.

Пример ответа на приведенный выше запрос может выглядеть следующим образом

```h
    HTTP/1.0 200 OK 
    Content-Type: text/plain
    Content-Length: 137582
    Expires: Thu, 05 Dec 1997 16:00:00 GMT
    Last-Modified: Wed, 5 August 1996 15:55:28 GMT
    Server: Apache 0.84

    (response body)
    (connection closed)
```
Одним из основных недостатков HTTP / 1.0 было невозможность выполнения нескольких запросов на одно соединение. То есть всякий раз, когда клиенту что-то понадобится от сервера, ему придется открывать новое TCP-соединение, и после того, как этот единственный запрос будет выполнен, соединение будет закрыто. И для любого следующего требования, он должен быть подключен к новому соединению.

### Three-way Handshake

Трехстороннее рукопожатие в его простой форме заключается в том, что все TCP-соединения начинаются с трехстороннего рукопожатия, при котором клиент и сервер обмениваются серией пакетов, прежде чем начать обмениваться данными приложения.

* SYN - клиент выбирает случайное число, скажем x, и отправляет его на сервер.
* SYN ACK - Сервер подтверждает запрос, отправляя пакет ACK обратно клиенту, который состоит из случайного числа, скажем, y, полученного сервером, и числа x + 1, где x - это число, отправленное клиентом
* ACK - клиент увеличивает число y, полученное от сервера, и отправляет обратно пакет ACK с числом y + 1

После завершения трехстороннего подтверждения связи может начаться обмен данными между клиентом и сервером. Следует отметить, что клиент может начать отправку данных приложения, как только он отправит последний подтверждающий пакет, но серверу все равно придется ждать получения подтверждающего пакета, чтобы выполнить запрос.

![Exemple of Three-way Handshake](https://i.imgur.com/ohZthqB.png)

### HTTP/1.1
Основные улучшения по сравнению с HTTP / 1.0 включали

* Были добавлены новые методы HTTP, которые представили PUT, PATCH, OPTIONS, DELETE

* Идентификация имени хоста В заголовке HTTP / 1.0 Host не требовалась, но HTTP / 1.1 сделал это обязательным.

* Были введены постоянные соединения, т. е. соединения не закрывались по умолчанию и оставались открытыми, что позволяло выполнять несколько последовательных запросов. Чтобы закрыть соединения, в запросе должен был быть доступен заголовок Connection: close . Клиенты обычно отправляют этот заголовок в последнем запросе, чтобы безопасно закрыть соединение.

* Конвейерная обработка Также была представлена поддержка конвейерной обработки, когда клиент мог отправлять несколько запросов на сервер, не дожидаясь ответа от сервера по тому же соединению, и сервер должен был отправлять ответ в той же последовательности, в которой были получены запросы. Но как клиент узнает, что на этом загрузка первого ответа завершается и начинается содержимое для следующего ответа, спросите вы! Ну, чтобы решить эту проблему, должен присутствовать заголовок Content-Length, который клиенты могут использовать для определения того, где заканчивается ответ, и он может начать ждать следующего ответа.

* Фрагментированные передачи В случае динамического содержимого, когда сервер не может точно определить длину содержимого при начале передачи, он может начать отправлять содержимое частями (фрагмент за фрагментом) и добавлять длину содержимого для каждого фрагмента при его отправке. И когда все фрагменты отправлены, т. е. передача целиком завершена, он отправляет пустой фрагмент, т. Е. Тот, длина содержимого которого равна нулю, чтобы идентифицировать клиента, передача которого завершена. Для того, чтобы уведомить клиента о фрагментированной передаче, сервер включает заголовок Transfer-Encoding: chunked

* В отличие от HTTP / 1.0, который имел только базовую аутентификацию, HTTP / 1.1 включал аутентификацию через дайджест и прокси

* Кэширование

* Диапазоны байтов

* Наборы символов

* Согласование языка

* Клиентские файлы cookie

### HTTP/2 - 2015

HTTP. HTTP / 2 был разработан для передачи контента с низкой задержкой. Ключевые особенности или отличия от старой версии HTTP / 1.1 включают

* Binary instead of Textual
* Multiplexing - несколько асинхронных HTTP-запросов через одно соединение
* Header compression using HPACK
* Server Push - несколько ответов на один запрос
* Приоритизация запросов
* Безопасность

#### Binary Protocol

HTTP / 2, как правило, решает проблему повышенной задержки, которая существовала в HTTP / 1.x, превращая его в двоичный протокол. Поскольку это двоичный протокол, его проще анализировать, но в отличие от HTTP / 1.x он больше не читаем человеческим глазом. Основными строительными блоками HTTP / 2 являются фреймы и потоки Frames and Streams

#### Frames and Streams

HTTP-сообщения теперь состоят из одного или нескольких фреймов. Существует фрейм HEADERS  для метаданных и фрейм DATA  для полезной нагрузки, а также существует несколько других типов фреймов (ЗHEADERS, DATA, RST_STREAM, SETTINGS, PRIORITY etc)

Каждому запросу и ответу HTTP / 2 присваивается уникальный идентификатор потока, и он разделяется на фреймы. Фреймы - это не что иное, как двоичные фрагменты данных. Набор фреймов называется потоком. Каждый фрейм имеет идентификатор потока, который идентифицирует поток, к которому он принадлежит, и каждый фрейм имеет общий заголовок. Также, помимо того, что идентификатор потока уникален, стоит упомянуть, что любой запрос, инициированный клиентом, использует нечетные числа, а ответ от сервера имеет идентификаторы потока четных чисел.

Помимо HEADERS and DATA, еще один тип фрейма, который, я думаю, стоит упомянуть здесь, - это RST_STREAM, который представляет собой специальный тип фрейма, который используется для прерывания некоторого потока, т.Е. клиент может отправить этот фрейм, чтобы сообщить серверу, что мне больше не нужен этот поток.

#### Multiplexing
Поскольку HTTP / 2 теперь является двоичным протоколом и, как я сказал выше, он использует фреймы и потоки для запросов и ответов, после открытия TCP-соединения все потоки отправляются асинхронно через одно и то же соединение без открытия каких-либо дополнительных подключений. И, в свою очередь, сервер отвечает таким же асинхронным образом, т. е. Ответ не имеет порядка, и клиент использует назначенный идентификатор потока для идентификации потока, к которому принадлежит конкретный пакет.
#### Server Push
Серверный push - это еще одна потрясающая функция HTTP / 2, при которой сервер, зная, что клиент собирается запросить определенный ресурс, может отправить его клиенту, даже не запрашивая его у клиента. Например, предположим, что браузер загружает веб-страницу, он анализирует всю страницу, чтобы найти удаленный контент, который он должен загрузить с сервера, а затем отправляет последующие запросы на сервер для получения этого контента.

Server push позволяет серверу уменьшить количество обходов, передавая данные, которые, как он знает, будет запрашивать клиент. Как это делается, сервер отправляет специальный фрейм с именем PUSH_PROMISE, уведомляющий клиента о том, что “Эй, я собираюсь отправить вам этот ресурс! Не спрашивайте меня об этом.” Фрейм PUSH_PROMISE связан с потоком, который вызвал отправку запроса, и он содержит обещанный идентификатор потока, то есть поток, по которому сервер отправит ресурс для отправки.

#### Определение приоритета запросов

Клиент может назначить приоритет потоку, включив информацию о приоритизации во фрейм HEADERS, с помощью которого открывается поток. В любое другое время клиент может отправить фрейм PRIORITY для изменения приоритета потока.

Без какой-либо информации о приоритете сервер обрабатывает запросы асинхронно, т.е. без какого-либо порядка. Если потоку присвоен приоритет, то на основе этой информации о приоритизации сервер решает, сколько ресурсов необходимо выделить для обработки того или иного запроса.
# BrowsersAndHowTheyWork?

# DNSAndHowItWorks?

# WhatIsDomainName?

# WhatIsHosting?